"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/iceberg-js@0.8.1";
exports.ids = ["vendor-chunks/iceberg-js@0.8.1"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/iceberg-js@0.8.1/node_modules/iceberg-js/dist/index.mjs":
/*!*************************************************************************************!*\
  !*** ../node_modules/.pnpm/iceberg-js@0.8.1/node_modules/iceberg-js/dist/index.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IcebergError: () => (/* binding */ IcebergError),\n/* harmony export */   IcebergRestCatalog: () => (/* binding */ IcebergRestCatalog),\n/* harmony export */   getCurrentSchema: () => (/* binding */ getCurrentSchema),\n/* harmony export */   isDecimalType: () => (/* binding */ isDecimalType),\n/* harmony export */   isFixedType: () => (/* binding */ isFixedType),\n/* harmony export */   parseDecimalType: () => (/* binding */ parseDecimalType),\n/* harmony export */   parseFixedType: () => (/* binding */ parseFixedType),\n/* harmony export */   typesEqual: () => (/* binding */ typesEqual)\n/* harmony export */ });\n// src/errors/IcebergError.ts\nvar IcebergError = class extends Error {\n    constructor(message, opts){\n        super(message);\n        this.name = \"IcebergError\";\n        this.status = opts.status;\n        this.icebergType = opts.icebergType;\n        this.icebergCode = opts.icebergCode;\n        this.details = opts.details;\n        this.isCommitStateUnknown = opts.icebergType === \"CommitStateUnknownException\" || [\n            500,\n            502,\n            504\n        ].includes(opts.status) && opts.icebergType?.includes(\"CommitState\") === true;\n    }\n    /**\n   * Returns true if the error is a 404 Not Found error.\n   */ isNotFound() {\n        return this.status === 404;\n    }\n    /**\n   * Returns true if the error is a 409 Conflict error.\n   */ isConflict() {\n        return this.status === 409;\n    }\n    /**\n   * Returns true if the error is a 419 Authentication Timeout error.\n   */ isAuthenticationTimeout() {\n        return this.status === 419;\n    }\n};\n// src/utils/url.ts\nfunction buildUrl(baseUrl, path, query) {\n    const url = new URL(path, baseUrl);\n    if (query) {\n        for (const [key, value] of Object.entries(query)){\n            if (value !== void 0) {\n                url.searchParams.set(key, value);\n            }\n        }\n    }\n    return url.toString();\n}\n// src/http/createFetchClient.ts\nasync function buildAuthHeaders(auth) {\n    if (!auth || auth.type === \"none\") {\n        return {};\n    }\n    if (auth.type === \"bearer\") {\n        return {\n            Authorization: `Bearer ${auth.token}`\n        };\n    }\n    if (auth.type === \"header\") {\n        return {\n            [auth.name]: auth.value\n        };\n    }\n    if (auth.type === \"custom\") {\n        return await auth.getHeaders();\n    }\n    return {};\n}\nfunction createFetchClient(options) {\n    const fetchFn = options.fetchImpl ?? globalThis.fetch;\n    return {\n        async request ({ method, path, query, body, headers }) {\n            const url = buildUrl(options.baseUrl, path, query);\n            const authHeaders = await buildAuthHeaders(options.auth);\n            const res = await fetchFn(url, {\n                method,\n                headers: {\n                    ...body ? {\n                        \"Content-Type\": \"application/json\"\n                    } : {},\n                    ...authHeaders,\n                    ...headers\n                },\n                body: body ? JSON.stringify(body) : void 0\n            });\n            const text = await res.text();\n            const isJson = (res.headers.get(\"content-type\") || \"\").includes(\"application/json\");\n            const data = isJson && text ? JSON.parse(text) : text;\n            if (!res.ok) {\n                const errBody = isJson ? data : void 0;\n                const errorDetail = errBody?.error;\n                throw new IcebergError(errorDetail?.message ?? `Request failed with status ${res.status}`, {\n                    status: res.status,\n                    icebergType: errorDetail?.type,\n                    icebergCode: errorDetail?.code,\n                    details: errBody\n                });\n            }\n            return {\n                status: res.status,\n                headers: res.headers,\n                data\n            };\n        }\n    };\n}\n// src/catalog/namespaces.ts\nfunction namespaceToPath(namespace) {\n    return namespace.join(\"\\x1f\");\n}\nvar NamespaceOperations = class {\n    constructor(client, prefix = \"\"){\n        this.client = client;\n        this.prefix = prefix;\n    }\n    async listNamespaces(parent) {\n        const query = parent ? {\n            parent: namespaceToPath(parent.namespace)\n        } : void 0;\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces`,\n            query\n        });\n        return response.data.namespaces.map((ns)=>({\n                namespace: ns\n            }));\n    }\n    async createNamespace(id, metadata) {\n        const request = {\n            namespace: id.namespace,\n            properties: metadata?.properties\n        };\n        const response = await this.client.request({\n            method: \"POST\",\n            path: `${this.prefix}/namespaces`,\n            body: request\n        });\n        return response.data;\n    }\n    async dropNamespace(id) {\n        await this.client.request({\n            method: \"DELETE\",\n            path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n        });\n    }\n    async loadNamespaceMetadata(id) {\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n        });\n        return {\n            properties: response.data.properties\n        };\n    }\n    async namespaceExists(id) {\n        try {\n            await this.client.request({\n                method: \"HEAD\",\n                path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n            });\n            return true;\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 404) {\n                return false;\n            }\n            throw error;\n        }\n    }\n    async createNamespaceIfNotExists(id, metadata) {\n        try {\n            return await this.createNamespace(id, metadata);\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 409) {\n                return;\n            }\n            throw error;\n        }\n    }\n};\n// src/catalog/tables.ts\nfunction namespaceToPath2(namespace) {\n    return namespace.join(\"\\x1f\");\n}\nvar TableOperations = class {\n    constructor(client, prefix = \"\", accessDelegation){\n        this.client = client;\n        this.prefix = prefix;\n        this.accessDelegation = accessDelegation;\n    }\n    async listTables(namespace) {\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`\n        });\n        return response.data.identifiers;\n    }\n    async createTable(namespace, request) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        const response = await this.client.request({\n            method: \"POST\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`,\n            body: request,\n            headers\n        });\n        return response.data.metadata;\n    }\n    async updateTable(id, request) {\n        const response = await this.client.request({\n            method: \"POST\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n            body: request\n        });\n        return {\n            \"metadata-location\": response.data[\"metadata-location\"],\n            metadata: response.data.metadata\n        };\n    }\n    async dropTable(id, options) {\n        await this.client.request({\n            method: \"DELETE\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n            query: {\n                purgeRequested: String(options?.purge ?? false)\n            }\n        });\n    }\n    async loadTable(id) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n            headers\n        });\n        return response.data.metadata;\n    }\n    async tableExists(id) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        try {\n            await this.client.request({\n                method: \"HEAD\",\n                path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n                headers\n            });\n            return true;\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 404) {\n                return false;\n            }\n            throw error;\n        }\n    }\n    async createTableIfNotExists(namespace, request) {\n        try {\n            return await this.createTable(namespace, request);\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 409) {\n                return await this.loadTable({\n                    namespace: namespace.namespace,\n                    name: request.name\n                });\n            }\n            throw error;\n        }\n    }\n};\n// src/catalog/IcebergRestCatalog.ts\nvar IcebergRestCatalog = class {\n    /**\n   * Creates a new Iceberg REST Catalog client.\n   *\n   * @param options - Configuration options for the catalog client\n   */ constructor(options){\n        let prefix = \"v1\";\n        if (options.catalogName) {\n            prefix += `/${options.catalogName}`;\n        }\n        const baseUrl = options.baseUrl.endsWith(\"/\") ? options.baseUrl : `${options.baseUrl}/`;\n        this.client = createFetchClient({\n            baseUrl,\n            auth: options.auth,\n            fetchImpl: options.fetch\n        });\n        this.accessDelegation = options.accessDelegation?.join(\",\");\n        this.namespaceOps = new NamespaceOperations(this.client, prefix);\n        this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);\n    }\n    /**\n   * Lists all namespaces in the catalog.\n   *\n   * @param parent - Optional parent namespace to list children under\n   * @returns Array of namespace identifiers\n   *\n   * @example\n   * ```typescript\n   * // List all top-level namespaces\n   * const namespaces = await catalog.listNamespaces();\n   *\n   * // List namespaces under a parent\n   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });\n   * ```\n   */ async listNamespaces(parent) {\n        return this.namespaceOps.listNamespaces(parent);\n    }\n    /**\n   * Creates a new namespace in the catalog.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespace(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * console.log(response.namespace); // ['analytics']\n   * console.log(response.properties); // { owner: 'data-team', ... }\n   * ```\n   */ async createNamespace(id, metadata) {\n        return this.namespaceOps.createNamespace(id, metadata);\n    }\n    /**\n   * Drops a namespace from the catalog.\n   *\n   * The namespace must be empty (contain no tables) before it can be dropped.\n   *\n   * @param id - Namespace identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropNamespace({ namespace: ['analytics'] });\n   * ```\n   */ async dropNamespace(id) {\n        await this.namespaceOps.dropNamespace(id);\n    }\n    /**\n   * Loads metadata for a namespace.\n   *\n   * @param id - Namespace identifier to load\n   * @returns Namespace metadata including properties\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });\n   * console.log(metadata.properties);\n   * ```\n   */ async loadNamespaceMetadata(id) {\n        return this.namespaceOps.loadNamespaceMetadata(id);\n    }\n    /**\n   * Lists all tables in a namespace.\n   *\n   * @param namespace - Namespace identifier to list tables from\n   * @returns Array of table identifiers\n   *\n   * @example\n   * ```typescript\n   * const tables = await catalog.listTables({ namespace: ['analytics'] });\n   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]\n   * ```\n   */ async listTables(namespace) {\n        return this.tableOps.listTables(namespace);\n    }\n    /**\n   * Creates a new table in the catalog.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTable(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     },\n   *     'partition-spec': {\n   *       'spec-id': 0,\n   *       fields: [\n   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }\n   *       ]\n   *     }\n   *   }\n   * );\n   * ```\n   */ async createTable(namespace, request) {\n        return this.tableOps.createTable(namespace, request);\n    }\n    /**\n   * Updates an existing table's metadata.\n   *\n   * Can update the schema, partition spec, or properties of a table.\n   *\n   * @param id - Table identifier to update\n   * @param request - Update request with fields to modify\n   * @returns Response containing the metadata location and updated table metadata\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.updateTable(\n   *   { namespace: ['analytics'], name: 'events' },\n   *   {\n   *     properties: { 'read.split.target-size': '134217728' }\n   *   }\n   * );\n   * console.log(response['metadata-location']); // s3://...\n   * console.log(response.metadata); // TableMetadata object\n   * ```\n   */ async updateTable(id, request) {\n        return this.tableOps.updateTable(id, request);\n    }\n    /**\n   * Drops a table from the catalog.\n   *\n   * @param id - Table identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });\n   * ```\n   */ async dropTable(id, options) {\n        await this.tableOps.dropTable(id, options);\n    }\n    /**\n   * Loads metadata for a table.\n   *\n   * @param id - Table identifier to load\n   * @returns Table metadata including schema, partition spec, location, etc.\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });\n   * console.log(metadata.schema);\n   * console.log(metadata.location);\n   * ```\n   */ async loadTable(id) {\n        return this.tableOps.loadTable(id);\n    }\n    /**\n   * Checks if a namespace exists in the catalog.\n   *\n   * @param id - Namespace identifier to check\n   * @returns True if the namespace exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });\n   * console.log(exists); // true or false\n   * ```\n   */ async namespaceExists(id) {\n        return this.namespaceOps.namespaceExists(id);\n    }\n    /**\n   * Checks if a table exists in the catalog.\n   *\n   * @param id - Table identifier to check\n   * @returns True if the table exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });\n   * console.log(exists); // true or false\n   * ```\n   */ async tableExists(id) {\n        return this.tableOps.tableExists(id);\n    }\n    /**\n   * Creates a namespace if it does not exist.\n   *\n   * If the namespace already exists, returns void. If created, returns the response.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties, or void if it already exists\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespaceIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * if (response) {\n   *   console.log('Created:', response.namespace);\n   * } else {\n   *   console.log('Already exists');\n   * }\n   * ```\n   */ async createNamespaceIfNotExists(id, metadata) {\n        return this.namespaceOps.createNamespaceIfNotExists(id, metadata);\n    }\n    /**\n   * Creates a table if it does not exist.\n   *\n   * If the table already exists, returns its metadata instead.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created or existing table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTableIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     }\n   *   }\n   * );\n   * ```\n   */ async createTableIfNotExists(namespace, request) {\n        return this.tableOps.createTableIfNotExists(namespace, request);\n    }\n};\n// src/catalog/types.ts\nvar DECIMAL_REGEX = /^decimal\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/;\nvar FIXED_REGEX = /^fixed\\s*\\[\\s*(\\d+)\\s*\\]$/;\nfunction parseDecimalType(type) {\n    const match = type.match(DECIMAL_REGEX);\n    if (!match) return null;\n    return {\n        precision: parseInt(match[1], 10),\n        scale: parseInt(match[2], 10)\n    };\n}\nfunction parseFixedType(type) {\n    const match = type.match(FIXED_REGEX);\n    if (!match) return null;\n    return {\n        length: parseInt(match[1], 10)\n    };\n}\nfunction isDecimalType(type) {\n    return DECIMAL_REGEX.test(type);\n}\nfunction isFixedType(type) {\n    return FIXED_REGEX.test(type);\n}\nfunction typesEqual(a, b) {\n    const decimalA = parseDecimalType(a);\n    const decimalB = parseDecimalType(b);\n    if (decimalA && decimalB) {\n        return decimalA.precision === decimalB.precision && decimalA.scale === decimalB.scale;\n    }\n    const fixedA = parseFixedType(a);\n    const fixedB = parseFixedType(b);\n    if (fixedA && fixedB) {\n        return fixedA.length === fixedB.length;\n    }\n    return a === b;\n}\nfunction getCurrentSchema(metadata) {\n    return metadata.schemas.find((s)=>s[\"schema-id\"] === metadata[\"current-schema-id\"]);\n}\n //# sourceMappingURL=index.mjs.map\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ljZWJlcmctanNAMC44LjEvbm9kZV9tb2R1bGVzL2ljZWJlcmctanMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSw2QkFBNkI7QUFDN0IsSUFBSUEsZUFBZSxjQUFjQztJQUMvQkMsWUFBWUMsT0FBTyxFQUFFQyxJQUFJLENBQUU7UUFDekIsS0FBSyxDQUFDRDtRQUNOLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxNQUFNLEdBQUdGLEtBQUtFLE1BQU07UUFDekIsSUFBSSxDQUFDQyxXQUFXLEdBQUdILEtBQUtHLFdBQVc7UUFDbkMsSUFBSSxDQUFDQyxXQUFXLEdBQUdKLEtBQUtJLFdBQVc7UUFDbkMsSUFBSSxDQUFDQyxPQUFPLEdBQUdMLEtBQUtLLE9BQU87UUFDM0IsSUFBSSxDQUFDQyxvQkFBb0IsR0FBR04sS0FBS0csV0FBVyxLQUFLLGlDQUFpQztZQUFDO1lBQUs7WUFBSztTQUFJLENBQUNJLFFBQVEsQ0FBQ1AsS0FBS0UsTUFBTSxLQUFLRixLQUFLRyxXQUFXLEVBQUVJLFNBQVMsbUJBQW1CO0lBQzNLO0lBQ0E7O0dBRUMsR0FDREMsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDTixNQUFNLEtBQUs7SUFDekI7SUFDQTs7R0FFQyxHQUNETyxhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUNQLE1BQU0sS0FBSztJQUN6QjtJQUNBOztHQUVDLEdBQ0RRLDBCQUEwQjtRQUN4QixPQUFPLElBQUksQ0FBQ1IsTUFBTSxLQUFLO0lBQ3pCO0FBQ0Y7QUFFQSxtQkFBbUI7QUFDbkIsU0FBU1MsU0FBU0MsT0FBTyxFQUFFQyxJQUFJLEVBQUVDLEtBQUs7SUFDcEMsTUFBTUMsTUFBTSxJQUFJQyxJQUFJSCxNQUFNRDtJQUMxQixJQUFJRSxPQUFPO1FBQ1QsS0FBSyxNQUFNLENBQUNHLEtBQUtDLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDTixPQUFRO1lBQ2hELElB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QUFFO0lBQzVCO0FBQ0Y7QUFDQSxTQUFTSSxlQUFlMUUsSUFBSTtJQUMxQixNQUFNc0UsUUFBUXRFLEtBQUtzRSxLQUFLLENBQUNGO0lBQ3pCLElBQUksQ0FBQ0UsT0FBTyxPQUFPO0lBQ25CLE9BQU87UUFDTEssUUFBUUgsU0FBU0YsS0FBSyxDQUFDLEVBQUUsRUFBRTtJQUM3QjtBQUNGO0FBQ0EsU0FBU00sY0FBYzVFLElBQUk7SUFDekIsT0FBT21FLGNBQWNVLElBQUksQ0FBQzdFO0FBQzVCO0FBQ0EsU0FBUzhFLFlBQVk5RSxJQUFJO0lBQ3ZCLE9BQU9vRSxZQUFZUyxJQUFJLENBQUM3RTtBQUMxQjtBQUNBLFNBQVMrRSxXQUFXQyxDQUFDLEVBQUVDLENBQUM7SUFDdEIsTUFBTUMsV0FBV2IsaUJBQWlCVztJQUNsQyxNQUFNRyxXQUFXZCxpQkFBaUJZO0lBQ2xDLElBQUlDLFlBQVlDLFVBQVU7UUFDeEIsT0FBT0QsU0FBU1gsU0FBUyxLQUFLWSxTQUFTWixTQUFTLElBQUlXLFNBQVNULEtBQUssS0FBS1UsU0FBU1YsS0FBSztJQUN2RjtJQUNBLE1BQU1XLFNBQVNWLGVBQWVNO0lBQzlCLE1BQU1LLFNBQVNYLGVBQWVPO0lBQzlCLElBQUlHLFVBQVVDLFFBQVE7UUFDcEIsT0FBT0QsT0FBT1QsTUFBTSxLQUFLVSxPQUFPVixNQUFNO0lBQ3hDO0lBQ0EsT0FBT0ssTUFBTUM7QUFDZjtBQUNBLFNBQVNLLGlCQUFpQjVDLFFBQVE7SUFDaEMsT0FBT0EsU0FBUzZDLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDLENBQUNDLElBQU1BLENBQUMsQ0FBQyxZQUFZLEtBQUsvQyxRQUFRLENBQUMsb0JBQW9CO0FBQ3RGO0FBRXdJLENBQ3hJLGtDQUFrQztDQUNsQyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcmVhZGluZy1jbGlwcGVyL3dlYi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaWNlYmVyZy1qc0AwLjguMS9ub2RlX21vZHVsZXMvaWNlYmVyZy1qcy9kaXN0L2luZGV4Lm1qcz9hMzU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9lcnJvcnMvSWNlYmVyZ0Vycm9yLnRzXG52YXIgSWNlYmVyZ0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkljZWJlcmdFcnJvclwiO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0cy5zdGF0dXM7XG4gICAgdGhpcy5pY2ViZXJnVHlwZSA9IG9wdHMuaWNlYmVyZ1R5cGU7XG4gICAgdGhpcy5pY2ViZXJnQ29kZSA9IG9wdHMuaWNlYmVyZ0NvZGU7XG4gICAgdGhpcy5kZXRhaWxzID0gb3B0cy5kZXRhaWxzO1xuICAgIHRoaXMuaXNDb21taXRTdGF0ZVVua25vd24gPSBvcHRzLmljZWJlcmdUeXBlID09PSBcIkNvbW1pdFN0YXRlVW5rbm93bkV4Y2VwdGlvblwiIHx8IFs1MDAsIDUwMiwgNTA0XS5pbmNsdWRlcyhvcHRzLnN0YXR1cykgJiYgb3B0cy5pY2ViZXJnVHlwZT8uaW5jbHVkZXMoXCJDb21taXRTdGF0ZVwiKSA9PT0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBlcnJvciBpcyBhIDQwNCBOb3QgRm91bmQgZXJyb3IuXG4gICAqL1xuICBpc05vdEZvdW5kKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gNDA0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVycm9yIGlzIGEgNDA5IENvbmZsaWN0IGVycm9yLlxuICAgKi9cbiAgaXNDb25mbGljdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IDQwOTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBlcnJvciBpcyBhIDQxOSBBdXRoZW50aWNhdGlvbiBUaW1lb3V0IGVycm9yLlxuICAgKi9cbiAgaXNBdXRoZW50aWNhdGlvblRpbWVvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSA0MTk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy91cmwudHNcbmZ1bmN0aW9uIGJ1aWxkVXJsKGJhc2VVcmwsIHBhdGgsIHF1ZXJ5KSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwocGF0aCwgYmFzZVVybCk7XG4gIGlmIChxdWVyeSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn1cblxuLy8gc3JjL2h0dHAvY3JlYXRlRmV0Y2hDbGllbnQudHNcbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkQXV0aEhlYWRlcnMoYXV0aCkge1xuICBpZiAoIWF1dGggfHwgYXV0aC50eXBlID09PSBcIm5vbmVcIikge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBpZiAoYXV0aC50eXBlID09PSBcImJlYXJlclwiKSB7XG4gICAgcmV0dXJuIHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2F1dGgudG9rZW59YCB9O1xuICB9XG4gIGlmIChhdXRoLnR5cGUgPT09IFwiaGVhZGVyXCIpIHtcbiAgICByZXR1cm4geyBbYXV0aC5uYW1lXTogYXV0aC52YWx1ZSB9O1xuICB9XG4gIGlmIChhdXRoLnR5cGUgPT09IFwiY3VzdG9tXCIpIHtcbiAgICByZXR1cm4gYXdhaXQgYXV0aC5nZXRIZWFkZXJzKCk7XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hDbGllbnQob3B0aW9ucykge1xuICBjb25zdCBmZXRjaEZuID0gb3B0aW9ucy5mZXRjaEltcGwgPz8gZ2xvYmFsVGhpcy5mZXRjaDtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyByZXF1ZXN0KHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHBhdGgsXG4gICAgICBxdWVyeSxcbiAgICAgIGJvZHksXG4gICAgICBoZWFkZXJzXG4gICAgfSkge1xuICAgICAgY29uc3QgdXJsID0gYnVpbGRVcmwob3B0aW9ucy5iYXNlVXJsLCBwYXRoLCBxdWVyeSk7XG4gICAgICBjb25zdCBhdXRoSGVhZGVycyA9IGF3YWl0IGJ1aWxkQXV0aEhlYWRlcnMob3B0aW9ucy5hdXRoKTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoRm4odXJsLCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmJvZHkgPyB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0gOiB7fSxcbiAgICAgICAgICAuLi5hdXRoSGVhZGVycyxcbiAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGJvZHkgPyBKU09OLnN0cmluZ2lmeShib2R5KSA6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIGNvbnN0IGlzSnNvbiA9IChyZXMuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIikuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgY29uc3QgZGF0YSA9IGlzSnNvbiAmJiB0ZXh0ID8gSlNPTi5wYXJzZSh0ZXh0KSA6IHRleHQ7XG4gICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICBjb25zdCBlcnJCb2R5ID0gaXNKc29uID8gZGF0YSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgZXJyb3JEZXRhaWwgPSBlcnJCb2R5Py5lcnJvcjtcbiAgICAgICAgdGhyb3cgbmV3IEljZWJlcmdFcnJvcihcbiAgICAgICAgICBlcnJvckRldGFpbD8ubWVzc2FnZSA/PyBgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgJHtyZXMuc3RhdHVzfWAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgICAgICAgaWNlYmVyZ1R5cGU6IGVycm9yRGV0YWlsPy50eXBlLFxuICAgICAgICAgICAgaWNlYmVyZ0NvZGU6IGVycm9yRGV0YWlsPy5jb2RlLFxuICAgICAgICAgICAgZGV0YWlsczogZXJyQm9keVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXR1czogcmVzLnN0YXR1cywgaGVhZGVyczogcmVzLmhlYWRlcnMsIGRhdGEgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9jYXRhbG9nL25hbWVzcGFjZXMudHNcbmZ1bmN0aW9uIG5hbWVzcGFjZVRvUGF0aChuYW1lc3BhY2UpIHtcbiAgcmV0dXJuIG5hbWVzcGFjZS5qb2luKFwiXHUwMDFmXCIpO1xufVxudmFyIE5hbWVzcGFjZU9wZXJhdGlvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgcHJlZml4ID0gXCJcIikge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICB9XG4gIGFzeW5jIGxpc3ROYW1lc3BhY2VzKHBhcmVudCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gcGFyZW50ID8geyBwYXJlbnQ6IG5hbWVzcGFjZVRvUGF0aChwYXJlbnQubmFtZXNwYWNlKSB9IDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlc2AsXG4gICAgICBxdWVyeVxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLm5hbWVzcGFjZXMubWFwKChucykgPT4gKHsgbmFtZXNwYWNlOiBucyB9KSk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlTmFtZXNwYWNlKGlkLCBtZXRhZGF0YSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICBuYW1lc3BhY2U6IGlkLm5hbWVzcGFjZSxcbiAgICAgIHByb3BlcnRpZXM6IG1ldGFkYXRhPy5wcm9wZXJ0aWVzXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzYCxcbiAgICAgIGJvZHk6IHJlcXVlc3RcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxuICBhc3luYyBkcm9wTmFtZXNwYWNlKGlkKSB7XG4gICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aChpZC5uYW1lc3BhY2UpfWBcbiAgICB9KTtcbiAgfVxuICBhc3luYyBsb2FkTmFtZXNwYWNlTWV0YWRhdGEoaWQpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgoaWQubmFtZXNwYWNlKX1gXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3BlcnRpZXM6IHJlc3BvbnNlLmRhdGEucHJvcGVydGllc1xuICAgIH07XG4gIH1cbiAgYXN5bmMgbmFtZXNwYWNlRXhpc3RzKGlkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IFwiSEVBRFwiLFxuICAgICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aChpZC5uYW1lc3BhY2UpfWBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEljZWJlcmdFcnJvciAmJiBlcnJvci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMoaWQsIG1ldGFkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZU5hbWVzcGFjZShpZCwgbWV0YWRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBJY2ViZXJnRXJyb3IgJiYgZXJyb3Iuc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvY2F0YWxvZy90YWJsZXMudHNcbmZ1bmN0aW9uIG5hbWVzcGFjZVRvUGF0aDIobmFtZXNwYWNlKSB7XG4gIHJldHVybiBuYW1lc3BhY2Uuam9pbihcIlx1MDAxZlwiKTtcbn1cbnZhciBUYWJsZU9wZXJhdGlvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgcHJlZml4ID0gXCJcIiwgYWNjZXNzRGVsZWdhdGlvbikge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIHRoaXMuYWNjZXNzRGVsZWdhdGlvbiA9IGFjY2Vzc0RlbGVnYXRpb247XG4gIH1cbiAgYXN5bmMgbGlzdFRhYmxlcyhuYW1lc3BhY2UpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgyKG5hbWVzcGFjZS5uYW1lc3BhY2UpfS90YWJsZXNgXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuaWRlbnRpZmllcnM7XG4gIH1cbiAgYXN5bmMgY3JlYXRlVGFibGUobmFtZXNwYWNlLCByZXF1ZXN0KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGlmICh0aGlzLmFjY2Vzc0RlbGVnYXRpb24pIHtcbiAgICAgIGhlYWRlcnNbXCJYLUljZWJlcmctQWNjZXNzLURlbGVnYXRpb25cIl0gPSB0aGlzLmFjY2Vzc0RlbGVnYXRpb247XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgyKG5hbWVzcGFjZS5uYW1lc3BhY2UpfS90YWJsZXNgLFxuICAgICAgYm9keTogcmVxdWVzdCxcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5tZXRhZGF0YTtcbiAgfVxuICBhc3luYyB1cGRhdGVUYWJsZShpZCwgcmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgyKGlkLm5hbWVzcGFjZSl9L3RhYmxlcy8ke2lkLm5hbWV9YCxcbiAgICAgIGJvZHk6IHJlcXVlc3RcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgXCJtZXRhZGF0YS1sb2NhdGlvblwiOiByZXNwb25zZS5kYXRhW1wibWV0YWRhdGEtbG9jYXRpb25cIl0sXG4gICAgICBtZXRhZGF0YTogcmVzcG9uc2UuZGF0YS5tZXRhZGF0YVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZHJvcFRhYmxlKGlkLCBvcHRpb25zKSB7XG4gICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIoaWQubmFtZXNwYWNlKX0vdGFibGVzLyR7aWQubmFtZX1gLFxuICAgICAgcXVlcnk6IHsgcHVyZ2VSZXF1ZXN0ZWQ6IFN0cmluZyhvcHRpb25zPy5wdXJnZSA/PyBmYWxzZSkgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGxvYWRUYWJsZShpZCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAodGhpcy5hY2Nlc3NEZWxlZ2F0aW9uKSB7XG4gICAgICBoZWFkZXJzW1wiWC1JY2ViZXJnLUFjY2Vzcy1EZWxlZ2F0aW9uXCJdID0gdGhpcy5hY2Nlc3NEZWxlZ2F0aW9uO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgyKGlkLm5hbWVzcGFjZSl9L3RhYmxlcy8ke2lkLm5hbWV9YCxcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5tZXRhZGF0YTtcbiAgfVxuICBhc3luYyB0YWJsZUV4aXN0cyhpZCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAodGhpcy5hY2Nlc3NEZWxlZ2F0aW9uKSB7XG4gICAgICBoZWFkZXJzW1wiWC1JY2ViZXJnLUFjY2Vzcy1EZWxlZ2F0aW9uXCJdID0gdGhpcy5hY2Nlc3NEZWxlZ2F0aW9uO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJIRUFEXCIsXG4gICAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoMihpZC5uYW1lc3BhY2UpfS90YWJsZXMvJHtpZC5uYW1lfWAsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEljZWJlcmdFcnJvciAmJiBlcnJvci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlVGFibGVJZk5vdEV4aXN0cyhuYW1lc3BhY2UsIHJlcXVlc3QpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlVGFibGUobmFtZXNwYWNlLCByZXF1ZXN0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSWNlYmVyZ0Vycm9yICYmIGVycm9yLnN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvYWRUYWJsZSh7IG5hbWVzcGFjZTogbmFtZXNwYWNlLm5hbWVzcGFjZSwgbmFtZTogcmVxdWVzdC5uYW1lIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvY2F0YWxvZy9JY2ViZXJnUmVzdENhdGFsb2cudHNcbnZhciBJY2ViZXJnUmVzdENhdGFsb2cgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEljZWJlcmcgUkVTVCBDYXRhbG9nIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBjYXRhbG9nIGNsaWVudFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGxldCBwcmVmaXggPSBcInYxXCI7XG4gICAgaWYgKG9wdGlvbnMuY2F0YWxvZ05hbWUpIHtcbiAgICAgIHByZWZpeCArPSBgLyR7b3B0aW9ucy5jYXRhbG9nTmFtZX1gO1xuICAgIH1cbiAgICBjb25zdCBiYXNlVXJsID0gb3B0aW9ucy5iYXNlVXJsLmVuZHNXaXRoKFwiL1wiKSA/IG9wdGlvbnMuYmFzZVVybCA6IGAke29wdGlvbnMuYmFzZVVybH0vYDtcbiAgICB0aGlzLmNsaWVudCA9IGNyZWF0ZUZldGNoQ2xpZW50KHtcbiAgICAgIGJhc2VVcmwsXG4gICAgICBhdXRoOiBvcHRpb25zLmF1dGgsXG4gICAgICBmZXRjaEltcGw6IG9wdGlvbnMuZmV0Y2hcbiAgICB9KTtcbiAgICB0aGlzLmFjY2Vzc0RlbGVnYXRpb24gPSBvcHRpb25zLmFjY2Vzc0RlbGVnYXRpb24/LmpvaW4oXCIsXCIpO1xuICAgIHRoaXMubmFtZXNwYWNlT3BzID0gbmV3IE5hbWVzcGFjZU9wZXJhdGlvbnModGhpcy5jbGllbnQsIHByZWZpeCk7XG4gICAgdGhpcy50YWJsZU9wcyA9IG5ldyBUYWJsZU9wZXJhdGlvbnModGhpcy5jbGllbnQsIHByZWZpeCwgdGhpcy5hY2Nlc3NEZWxlZ2F0aW9uKTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgYWxsIG5hbWVzcGFjZXMgaW4gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJlbnQgLSBPcHRpb25hbCBwYXJlbnQgbmFtZXNwYWNlIHRvIGxpc3QgY2hpbGRyZW4gdW5kZXJcbiAgICogQHJldHVybnMgQXJyYXkgb2YgbmFtZXNwYWNlIGlkZW50aWZpZXJzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogLy8gTGlzdCBhbGwgdG9wLWxldmVsIG5hbWVzcGFjZXNcbiAgICogY29uc3QgbmFtZXNwYWNlcyA9IGF3YWl0IGNhdGFsb2cubGlzdE5hbWVzcGFjZXMoKTtcbiAgICpcbiAgICogLy8gTGlzdCBuYW1lc3BhY2VzIHVuZGVyIGEgcGFyZW50XG4gICAqIGNvbnN0IGNoaWxkcmVuID0gYXdhaXQgY2F0YWxvZy5saXN0TmFtZXNwYWNlcyh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBsaXN0TmFtZXNwYWNlcyhwYXJlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VPcHMubGlzdE5hbWVzcGFjZXMocGFyZW50KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBuYW1lc3BhY2UgaW4gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSBPcHRpb25hbCBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciB0aGUgbmFtZXNwYWNlXG4gICAqIEByZXR1cm5zIFJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIGNyZWF0ZWQgbmFtZXNwYWNlIGFuZCBpdHMgcHJvcGVydGllc1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVOYW1lc3BhY2UoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSxcbiAgICogICB7IHByb3BlcnRpZXM6IHsgb3duZXI6ICdkYXRhLXRlYW0nIH0gfVxuICAgKiApO1xuICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS5uYW1lc3BhY2UpOyAvLyBbJ2FuYWx5dGljcyddXG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlLnByb3BlcnRpZXMpOyAvLyB7IG93bmVyOiAnZGF0YS10ZWFtJywgLi4uIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVOYW1lc3BhY2UoaWQsIG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLmNyZWF0ZU5hbWVzcGFjZShpZCwgbWV0YWRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBEcm9wcyBhIG5hbWVzcGFjZSBmcm9tIHRoZSBjYXRhbG9nLlxuICAgKlxuICAgKiBUaGUgbmFtZXNwYWNlIG11c3QgYmUgZW1wdHkgKGNvbnRhaW4gbm8gdGFibGVzKSBiZWZvcmUgaXQgY2FuIGJlIGRyb3BwZWQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGRyb3BcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBhd2FpdCBjYXRhbG9nLmRyb3BOYW1lc3BhY2UoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZHJvcE5hbWVzcGFjZShpZCkge1xuICAgIGF3YWl0IHRoaXMubmFtZXNwYWNlT3BzLmRyb3BOYW1lc3BhY2UoaWQpO1xuICB9XG4gIC8qKlxuICAgKiBMb2FkcyBtZXRhZGF0YSBmb3IgYSBuYW1lc3BhY2UuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGxvYWRcbiAgICogQHJldHVybnMgTmFtZXNwYWNlIG1ldGFkYXRhIGluY2x1ZGluZyBwcm9wZXJ0aWVzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBjYXRhbG9nLmxvYWROYW1lc3BhY2VNZXRhZGF0YSh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9KTtcbiAgICogY29uc29sZS5sb2cobWV0YWRhdGEucHJvcGVydGllcyk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgbG9hZE5hbWVzcGFjZU1ldGFkYXRhKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLmxvYWROYW1lc3BhY2VNZXRhZGF0YShpZCk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RzIGFsbCB0YWJsZXMgaW4gYSBuYW1lc3BhY2UuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBOYW1lc3BhY2UgaWRlbnRpZmllciB0byBsaXN0IHRhYmxlcyBmcm9tXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIHRhYmxlIGlkZW50aWZpZXJzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgdGFibGVzID0gYXdhaXQgY2F0YWxvZy5saXN0VGFibGVzKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICAgKiBjb25zb2xlLmxvZyh0YWJsZXMpOyAvLyBbeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0sIC4uLl1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBsaXN0VGFibGVzKG5hbWVzcGFjZSkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmxpc3RUYWJsZXMobmFtZXNwYWNlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0YWJsZSBpbiB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWVzcGFjZSAtIE5hbWVzcGFjZSB0byBjcmVhdGUgdGhlIHRhYmxlIGluXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gVGFibGUgY3JlYXRpb24gcmVxdWVzdCBpbmNsdWRpbmcgbmFtZSwgc2NoZW1hLCBwYXJ0aXRpb24gc3BlYywgZXRjLlxuICAgKiBAcmV0dXJucyBUYWJsZSBtZXRhZGF0YSBmb3IgdGhlIGNyZWF0ZWQgdGFibGVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNhdGFsb2cuY3JlYXRlVGFibGUoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSxcbiAgICogICB7XG4gICAqICAgICBuYW1lOiAnZXZlbnRzJyxcbiAgICogICAgIHNjaGVtYToge1xuICAgKiAgICAgICB0eXBlOiAnc3RydWN0JyxcbiAgICogICAgICAgZmllbGRzOiBbXG4gICAqICAgICAgICAgeyBpZDogMSwgbmFtZTogJ2lkJywgdHlwZTogJ2xvbmcnLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgKiAgICAgICAgIHsgaWQ6IDIsIG5hbWU6ICd0aW1lc3RhbXAnLCB0eXBlOiAndGltZXN0YW1wJywgcmVxdWlyZWQ6IHRydWUgfVxuICAgKiAgICAgICBdLFxuICAgKiAgICAgICAnc2NoZW1hLWlkJzogMFxuICAgKiAgICAgfSxcbiAgICogICAgICdwYXJ0aXRpb24tc3BlYyc6IHtcbiAgICogICAgICAgJ3NwZWMtaWQnOiAwLFxuICAgKiAgICAgICBmaWVsZHM6IFtcbiAgICogICAgICAgICB7IHNvdXJjZV9pZDogMiwgZmllbGRfaWQ6IDEwMDAsIG5hbWU6ICd0c19kYXknLCB0cmFuc2Zvcm06ICdkYXknIH1cbiAgICogICAgICAgXVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVUYWJsZShuYW1lc3BhY2UsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy5jcmVhdGVUYWJsZShuYW1lc3BhY2UsIHJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIHRhYmxlJ3MgbWV0YWRhdGEuXG4gICAqXG4gICAqIENhbiB1cGRhdGUgdGhlIHNjaGVtYSwgcGFydGl0aW9uIHNwZWMsIG9yIHByb3BlcnRpZXMgb2YgYSB0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGFibGUgaWRlbnRpZmllciB0byB1cGRhdGVcbiAgICogQHBhcmFtIHJlcXVlc3QgLSBVcGRhdGUgcmVxdWVzdCB3aXRoIGZpZWxkcyB0byBtb2RpZnlcbiAgICogQHJldHVybnMgUmVzcG9uc2UgY29udGFpbmluZyB0aGUgbWV0YWRhdGEgbG9jYXRpb24gYW5kIHVwZGF0ZWQgdGFibGUgbWV0YWRhdGFcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhdGFsb2cudXBkYXRlVGFibGUoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0sXG4gICAqICAge1xuICAgKiAgICAgcHJvcGVydGllczogeyAncmVhZC5zcGxpdC50YXJnZXQtc2l6ZSc6ICcxMzQyMTc3MjgnIH1cbiAgICogICB9XG4gICAqICk7XG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlWydtZXRhZGF0YS1sb2NhdGlvbiddKTsgLy8gczM6Ly8uLi5cbiAgICogY29uc29sZS5sb2cocmVzcG9uc2UubWV0YWRhdGEpOyAvLyBUYWJsZU1ldGFkYXRhIG9iamVjdFxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHVwZGF0ZVRhYmxlKGlkLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGVPcHMudXBkYXRlVGFibGUoaWQsIHJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBEcm9wcyBhIHRhYmxlIGZyb20gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFRhYmxlIGlkZW50aWZpZXIgdG8gZHJvcFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGF3YWl0IGNhdGFsb2cuZHJvcFRhYmxlKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddLCBuYW1lOiAnZXZlbnRzJyB9KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBkcm9wVGFibGUoaWQsIG9wdGlvbnMpIHtcbiAgICBhd2FpdCB0aGlzLnRhYmxlT3BzLmRyb3BUYWJsZShpZCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIExvYWRzIG1ldGFkYXRhIGZvciBhIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBUYWJsZSBpZGVudGlmaWVyIHRvIGxvYWRcbiAgICogQHJldHVybnMgVGFibGUgbWV0YWRhdGEgaW5jbHVkaW5nIHNjaGVtYSwgcGFydGl0aW9uIHNwZWMsIGxvY2F0aW9uLCBldGMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBjYXRhbG9nLmxvYWRUYWJsZSh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSwgbmFtZTogJ2V2ZW50cycgfSk7XG4gICAqIGNvbnNvbGUubG9nKG1ldGFkYXRhLnNjaGVtYSk7XG4gICAqIGNvbnNvbGUubG9nKG1ldGFkYXRhLmxvY2F0aW9uKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBsb2FkVGFibGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy5sb2FkVGFibGUoaWQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBuYW1lc3BhY2UgZXhpc3RzIGluIHRoZSBjYXRhbG9nLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBOYW1lc3BhY2UgaWRlbnRpZmllciB0byBjaGVja1xuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBuYW1lc3BhY2UgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBleGlzdHMgPSBhd2FpdCBjYXRhbG9nLm5hbWVzcGFjZUV4aXN0cyh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9KTtcbiAgICogY29uc29sZS5sb2coZXhpc3RzKTsgLy8gdHJ1ZSBvciBmYWxzZVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIG5hbWVzcGFjZUV4aXN0cyhpZCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZU9wcy5uYW1lc3BhY2VFeGlzdHMoaWQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSB0YWJsZSBleGlzdHMgaW4gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFRhYmxlIGlkZW50aWZpZXIgdG8gY2hlY2tcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdGFibGUgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBleGlzdHMgPSBhd2FpdCBjYXRhbG9nLnRhYmxlRXhpc3RzKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddLCBuYW1lOiAnZXZlbnRzJyB9KTtcbiAgICogY29uc29sZS5sb2coZXhpc3RzKTsgLy8gdHJ1ZSBvciBmYWxzZVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHRhYmxlRXhpc3RzKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGVPcHMudGFibGVFeGlzdHMoaWQpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmFtZXNwYWNlIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBJZiB0aGUgbmFtZXNwYWNlIGFscmVhZHkgZXhpc3RzLCByZXR1cm5zIHZvaWQuIElmIGNyZWF0ZWQsIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBOYW1lc3BhY2UgaWRlbnRpZmllciB0byBjcmVhdGVcbiAgICogQHBhcmFtIG1ldGFkYXRhIC0gT3B0aW9uYWwgbWV0YWRhdGEgcHJvcGVydGllcyBmb3IgdGhlIG5hbWVzcGFjZVxuICAgKiBAcmV0dXJucyBSZXNwb25zZSBjb250YWluaW5nIHRoZSBjcmVhdGVkIG5hbWVzcGFjZSBhbmQgaXRzIHByb3BlcnRpZXMsIG9yIHZvaWQgaWYgaXQgYWxyZWFkeSBleGlzdHNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhdGFsb2cuY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSxcbiAgICogICB7IHByb3BlcnRpZXM6IHsgb3duZXI6ICdkYXRhLXRlYW0nIH0gfVxuICAgKiApO1xuICAgKiBpZiAocmVzcG9uc2UpIHtcbiAgICogICBjb25zb2xlLmxvZygnQ3JlYXRlZDonLCByZXNwb25zZS5uYW1lc3BhY2UpO1xuICAgKiB9IGVsc2Uge1xuICAgKiAgIGNvbnNvbGUubG9nKCdBbHJlYWR5IGV4aXN0cycpO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMoaWQsIG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLmNyZWF0ZU5hbWVzcGFjZUlmTm90RXhpc3RzKGlkLCBtZXRhZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0YWJsZSBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogSWYgdGhlIHRhYmxlIGFscmVhZHkgZXhpc3RzLCByZXR1cm5zIGl0cyBtZXRhZGF0YSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gTmFtZXNwYWNlIHRvIGNyZWF0ZSB0aGUgdGFibGUgaW5cbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUYWJsZSBjcmVhdGlvbiByZXF1ZXN0IGluY2x1ZGluZyBuYW1lLCBzY2hlbWEsIHBhcnRpdGlvbiBzcGVjLCBldGMuXG4gICAqIEByZXR1cm5zIFRhYmxlIG1ldGFkYXRhIGZvciB0aGUgY3JlYXRlZCBvciBleGlzdGluZyB0YWJsZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVUYWJsZUlmTm90RXhpc3RzKFxuICAgKiAgIHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0sXG4gICAqICAge1xuICAgKiAgICAgbmFtZTogJ2V2ZW50cycsXG4gICAqICAgICBzY2hlbWE6IHtcbiAgICogICAgICAgdHlwZTogJ3N0cnVjdCcsXG4gICAqICAgICAgIGZpZWxkczogW1xuICAgKiAgICAgICAgIHsgaWQ6IDEsIG5hbWU6ICdpZCcsIHR5cGU6ICdsb25nJywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICogICAgICAgICB7IGlkOiAyLCBuYW1lOiAndGltZXN0YW1wJywgdHlwZTogJ3RpbWVzdGFtcCcsIHJlcXVpcmVkOiB0cnVlIH1cbiAgICogICAgICAgXSxcbiAgICogICAgICAgJ3NjaGVtYS1pZCc6IDBcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqICk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlVGFibGVJZk5vdEV4aXN0cyhuYW1lc3BhY2UsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy5jcmVhdGVUYWJsZUlmTm90RXhpc3RzKG5hbWVzcGFjZSwgcmVxdWVzdCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jYXRhbG9nL3R5cGVzLnRzXG52YXIgREVDSU1BTF9SRUdFWCA9IC9eZGVjaW1hbFxccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKlxcKSQvO1xudmFyIEZJWEVEX1JFR0VYID0gL15maXhlZFxccypcXFtcXHMqKFxcZCspXFxzKlxcXSQvO1xuZnVuY3Rpb24gcGFyc2VEZWNpbWFsVHlwZSh0eXBlKSB7XG4gIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChERUNJTUFMX1JFR0VYKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiB7XG4gICAgcHJlY2lzaW9uOiBwYXJzZUludChtYXRjaFsxXSwgMTApLFxuICAgIHNjYWxlOiBwYXJzZUludChtYXRjaFsyXSwgMTApXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUZpeGVkVHlwZSh0eXBlKSB7XG4gIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChGSVhFRF9SRUdFWCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICByZXR1cm4ge1xuICAgIGxlbmd0aDogcGFyc2VJbnQobWF0Y2hbMV0sIDEwKVxuICB9O1xufVxuZnVuY3Rpb24gaXNEZWNpbWFsVHlwZSh0eXBlKSB7XG4gIHJldHVybiBERUNJTUFMX1JFR0VYLnRlc3QodHlwZSk7XG59XG5mdW5jdGlvbiBpc0ZpeGVkVHlwZSh0eXBlKSB7XG4gIHJldHVybiBGSVhFRF9SRUdFWC50ZXN0KHR5cGUpO1xufVxuZnVuY3Rpb24gdHlwZXNFcXVhbChhLCBiKSB7XG4gIGNvbnN0IGRlY2ltYWxBID0gcGFyc2VEZWNpbWFsVHlwZShhKTtcbiAgY29uc3QgZGVjaW1hbEIgPSBwYXJzZURlY2ltYWxUeXBlKGIpO1xuICBpZiAoZGVjaW1hbEEgJiYgZGVjaW1hbEIpIHtcbiAgICByZXR1cm4gZGVjaW1hbEEucHJlY2lzaW9uID09PSBkZWNpbWFsQi5wcmVjaXNpb24gJiYgZGVjaW1hbEEuc2NhbGUgPT09IGRlY2ltYWxCLnNjYWxlO1xuICB9XG4gIGNvbnN0IGZpeGVkQSA9IHBhcnNlRml4ZWRUeXBlKGEpO1xuICBjb25zdCBmaXhlZEIgPSBwYXJzZUZpeGVkVHlwZShiKTtcbiAgaWYgKGZpeGVkQSAmJiBmaXhlZEIpIHtcbiAgICByZXR1cm4gZml4ZWRBLmxlbmd0aCA9PT0gZml4ZWRCLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYSA9PT0gYjtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY2hlbWEobWV0YWRhdGEpIHtcbiAgcmV0dXJuIG1ldGFkYXRhLnNjaGVtYXMuZmluZCgocykgPT4gc1tcInNjaGVtYS1pZFwiXSA9PT0gbWV0YWRhdGFbXCJjdXJyZW50LXNjaGVtYS1pZFwiXSk7XG59XG5cbmV4cG9ydCB7IEljZWJlcmdFcnJvciwgSWNlYmVyZ1Jlc3RDYXRhbG9nLCBnZXRDdXJyZW50U2NoZW1hLCBpc0RlY2ltYWxUeXBlLCBpc0ZpeGVkVHlwZSwgcGFyc2VEZWNpbWFsVHlwZSwgcGFyc2VGaXhlZFR5cGUsIHR5cGVzRXF1YWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiSWNlYmVyZ0Vycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJvcHRzIiwibmFtZSIsInN0YXR1cyIsImljZWJlcmdUeXBlIiwiaWNlYmVyZ0NvZGUiLCJkZXRhaWxzIiwiaXNDb21taXRTdGF0ZVVua25vd24iLCJpbmNsdWRlcyIsImlzTm90Rm91bmQiLCJpc0NvbmZsaWN0IiwiaXNBdXRoZW50aWNhdGlvblRpbWVvdXQiLCJidWlsZFVybCIsImJhc2VVcmwiLCJwYXRoIiwicXVlcnkiLCJ1cmwiLCJVUkwiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJzZWFyY2hQYXJhbXMiLCJzZXQiLCJ0b1N0cmluZyIsImJ1aWxkQXV0aEhlYWRlcnMiLCJhdXRoIiwidHlwZSIsIkF1dGhvcml6YXRpb24iLCJ0b2tlbiIsImdldEhlYWRlcnMiLCJjcmVhdGVGZXRjaENsaWVudCIsIm9wdGlvbnMiLCJmZXRjaEZuIiwiZmV0Y2hJbXBsIiwiZ2xvYmFsVGhpcyIsImZldGNoIiwicmVxdWVzdCIsIm1ldGhvZCIsImJvZHkiLCJoZWFkZXJzIiwiYXV0aEhlYWRlcnMiLCJyZXMiLCJKU09OIiwic3RyaW5naWZ5IiwidGV4dCIsImlzSnNvbiIsImdldCIsImRhdGEiLCJwYXJzZSIsIm9rIiwiZXJyQm9keSIsImVycm9yRGV0YWlsIiwiZXJyb3IiLCJjb2RlIiwibmFtZXNwYWNlVG9QYXRoIiwibmFtZXNwYWNlIiwiam9pbiIsIk5hbWVzcGFjZU9wZXJhdGlvbnMiLCJjbGllbnQiLCJwcmVmaXgiLCJsaXN0TmFtZXNwYWNlcyIsInBhcmVudCIsInJlc3BvbnNlIiwibmFtZXNwYWNlcyIsIm1hcCIsIm5zIiwiY3JlYXRlTmFtZXNwYWNlIiwiaWQiLCJtZXRhZGF0YSIsInByb3BlcnRpZXMiLCJkcm9wTmFtZXNwYWNlIiwibG9hZE5hbWVzcGFjZU1ldGFkYXRhIiwibmFtZXNwYWNlRXhpc3RzIiwiY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMiLCJuYW1lc3BhY2VUb1BhdGgyIiwiVGFibGVPcGVyYXRpb25zIiwiYWNjZXNzRGVsZWdhdGlvbiIsImxpc3RUYWJsZXMiLCJpZGVudGlmaWVycyIsImNyZWF0ZVRhYmxlIiwidXBkYXRlVGFibGUiLCJkcm9wVGFibGUiLCJwdXJnZVJlcXVlc3RlZCIsIlN0cmluZyIsInB1cmdlIiwibG9hZFRhYmxlIiwidGFibGVFeGlzdHMiLCJjcmVhdGVUYWJsZUlmTm90RXhpc3RzIiwiSWNlYmVyZ1Jlc3RDYXRhbG9nIiwiY2F0YWxvZ05hbWUiLCJlbmRzV2l0aCIsIm5hbWVzcGFjZU9wcyIsInRhYmxlT3BzIiwiREVDSU1BTF9SRUdFWCIsIkZJWEVEX1JFR0VYIiwicGFyc2VEZWNpbWFsVHlwZSIsIm1hdGNoIiwicHJlY2lzaW9uIiwicGFyc2VJbnQiLCJzY2FsZSIsInBhcnNlRml4ZWRUeXBlIiwibGVuZ3RoIiwiaXNEZWNpbWFsVHlwZSIsInRlc3QiLCJpc0ZpeGVkVHlwZSIsInR5cGVzRXF1YWwiLCJhIiwiYiIsImRlY2ltYWxBIiwiZGVjaW1hbEIiLCJmaXhlZEEiLCJmaXhlZEIiLCJnZXRDdXJyZW50U2NoZW1hIiwic2NoZW1hcyIsImZpbmQiLCJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/iceberg-js@0.8.1/node_modules/iceberg-js/dist/index.mjs\n");

/***/ })

};
;